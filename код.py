# -*- coding: utf-8 -*-
"""Код

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SVobq7g2W-mNvPxOwuCc213AMVveSYPA
"""

import random
import json
from datetime import datetime
from abc import ABC, abstractmethod

# === КОД ИЗ ФАЙЛА "код.docx" ===

# Дескриптор для валидации характеристик
class BoundedStat:
    def __init__(self, min_val=0, max_val=100):
        self.min_val = min_val
        self.max_val = max_val

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name, self.min_val)

    def __set__(self, instance, value):
        if not (self.min_val <= value <= self.max_val):
            raise ValueError(f"{self.name} must be between {self.min_val} and {self.max_val}")
        instance.__dict__[self.name] = value

# Базовый класс Human
class Human:
    hp = BoundedStat(0, 1000)
    mp = BoundedStat(0, 500)
    strength = BoundedStat(1, 100)
    agility = BoundedStat(1, 100)
    intellect = BoundedStat(1, 100)

    def __init__(self, name, level=1):
        self.name = name
        self.level = level
        self._hp = 100
        self._mp = 50
        self._strength = 10
        self._agility = 10
        self._intellect = 10
        self.max_hp = 100
        self.max_mp = 50

    @property
    def is_alive(self):
        return self.hp > 0

    def __str__(self):
        return f"{self.name} (Lvl {self.level}) - HP: {self.hp}/{self.max_hp}, MP: {self.mp}/{self.max_mp}"

    def __repr__(self):
        return f"{self.__class__.__name__}('{self.name}', {self.level})"

# Миксин для логирования
class LoggerMixin:
    def log(self, message):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] {message}")

# Миксин для критического удара
class CritMixin:
    def calculate_crit(self, base_damage, crit_chance=0.1):
        if random.random() < crit_chance:
            self.log(f"{self.name} наносит критический удар!")
            return base_damage * 2
        return base_damage

# Классы эффектов
class Effect(ABC):
    def __init__(self, name, duration):
        self.name = name
        self.duration = duration
        self.original_duration = duration
        self.applied = False

    @abstractmethod
    def apply(self, target):
        pass

    @abstractmethod
    def remove(self, target):
        pass

class BurnEffect(Effect):
    def __init__(self, name, duration, damage_per_turn):
        super().__init__(name, duration)
        self.damage_per_turn = damage_per_turn

    def apply(self, target):
        target.hp -= self.damage_per_turn
        target.log(f"{target.name} горит и получает {self.damage_per_turn} урона!")

    def remove(self, target):
        target.log(f"Эффект горения с {target.name} снят")

class ShieldEffect(Effect):
    def __init__(self, name, duration, shield_amount):
        super().__init__(name, duration)
        self.shield_amount = shield_amount
        self.original_max_hp = 0

    def apply(self, target):
        if not self.applied:
            self.applied = True
            self.original_max_hp = target.max_hp
            target.max_hp += self.shield_amount
            target.hp += self.shield_amount
            target.log(f"{target.name} получает щит на {self.shield_amount} HP!")

    def remove(self, target):
        if self.applied:
            target.max_hp = self.original_max_hp
            target.hp = min(target.hp, target.max_hp)
            target.log(f"Щит с {target.name} снят")

class SlowEffect(Effect):
    def __init__(self, name, duration):
        super().__init__(name, duration)
        self.original_agility = 0

    def apply(self, target):
        if not self.applied:
            self.applied = True
            self.original_agility = target.agility
            target.agility = max(1, target.agility // 2)
            target.log(f"{target.name} замедлен! Ловкость уменьшена до {target.agility}")

    def remove(self, target):
        if self.applied:
            target.agility = self.original_agility
            target.log(f"Замедление с {target.name} снято. Ловкость восстановлена до {target.agility}")

# Абстрактный класс Character
class Character(Human, ABC, LoggerMixin, CritMixin):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self.skills = []
        self.effects = []
        self.cooldowns = {}
        self.inventory = []

    @abstractmethod
    def basic_attack(self, target):
        pass

    @abstractmethod
    def use_skill(self, skill_index, target):
        pass

    def add_effect(self, effect):
        self.effects.append(effect)
        self.log(f"{self.name} получает эффект: {effect.name}")

    def remove_effect(self, effect):
        if effect in self.effects:
            self.effects.remove(effect)
            self.log(f"Эффект {effect.name} с {self.name} снят")

    def update_effects(self):
        effects_to_remove = []
        for effect in self.effects:
            effect.apply(self)
            effect.duration -= 1
            if effect.duration <= 0:
                effects_to_remove.append(effect)
        for effect in effects_to_remove:
            effect.remove(self)
            self.remove_effect(effect)

    def update_cooldowns(self):
        for skill in self.cooldowns:
            if self.cooldowns[skill] > 0:
                self.cooldowns[skill] -= 1

    def __str__(self):
        base_str = super().__str__()
        effects_str = ", ".join([f"{eff.name}({eff.duration})" for eff in self.effects]) if self.effects else "нет"
        return f"{base_str} | Эффекты: {effects_str}"

# Классы персонажей
class Warrior(Character):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._strength = 20 + level * 2
        self._agility = 10 + level
        self._intellect = 5 + level
        self.max_hp = 150 + level * 10
        self.hp = self.max_hp
        self.max_mp = 30 + level * 2
        self.mp = self.max_mp
        self.skills = ["Сильный удар", "Защитная стойка", "Размашистый удар"]
        self.cooldowns = {skill: 0 for skill in self.skills}

    def basic_attack(self, target):
        damage = self.calculate_crit(self.strength + random.randint(1, 5))
        target.hp = max(0, target.hp - damage)
        self.log(f"{self.name} атакует {target.name} и наносит {damage} урона!")
        return damage

    def use_skill(self, skill_index, target):
        if skill_index >= len(self.skills):
            self.log("Неверный индекс навыка!")
            return 0
        skill = self.skills[skill_index]
        if self.cooldowns[skill] > 0:
            self.log(f"Навык {skill} на перезарядке! Осталось ходов: {self.cooldowns[skill]}")
            return 0
        if skill == "Сильный удар":
            if self.mp < 10:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 10
            damage = self.calculate_crit(self.strength * 2 + random.randint(5, 10), 0.2)
            target.hp = max(0, target.hp - damage)
            self.cooldowns[skill] = 2
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage
        elif skill == "Защитная стойка":
            if self.mp < 15:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 15
            self.add_effect(ShieldEffect("Щит воина", 2, self.strength))
            self.cooldowns[skill] = 3
            self.log(f"{self.name} использует {skill} и получает щит!")
            return 0
        elif skill == "Размашистый удар":
            if self.mp < 20:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 20
            damage = self.calculate_crit(self.strength * 1.5 + random.randint(3, 8), 0.15)
            target.hp = max(0, target.hp - damage)
            self.cooldowns[skill] = 4
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage

class Mage(Character):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._strength = 5 + level
        self._agility = 8 + level
        self._intellect = 25 + level * 3
        self.max_hp = 80 + level * 5
        self.hp = self.max_hp
        self.max_mp = 100 + level * 8
        self.mp = self.max_mp
        self.skills = ["Огненный шар", "Ледяная стрела", "Магический щит"]
        self.cooldowns = {skill: 0 for skill in self.skills}

    def basic_attack(self, target):
        damage = self.calculate_crit(self.intellect // 2 + random.randint(1, 3))
        target.hp = max(0, target.hp - damage)
        self.log(f"{self.name} атакует {target.name} магией и наносит {damage} урона!")
        return damage

    def use_skill(self, skill_index, target):
        if skill_index >= len(self.skills):
            self.log("Неверный индекс навыка!")
            return 0
        skill = self.skills[skill_index]
        if self.cooldowns[skill] > 0:
            self.log(f"Навык {skill} на перезарядке! Осталось ходов: {self.cooldowns[skill]}")
            return 0
        if skill == "Огненный шар":
            if self.mp < 25:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 25
            damage = self.calculate_crit(self.intellect * 1.5 + random.randint(5, 15), 0.25)
            target.hp = max(0, target.hp - damage)
            target.add_effect(BurnEffect("Горение", 3, self.intellect // 4))
            self.cooldowns[skill] = 3
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage
        elif skill == "Ледяная стрела":
            if self.mp < 20:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 20
            damage = self.calculate_crit(self.intellect + random.randint(3, 10), 0.2)
            target.hp = max(0, target.hp - damage)
            target.add_effect(SlowEffect("Замедление", 2))
            self.cooldowns[skill] = 2
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage
        elif skill == "Магический щит":
            if self.mp < 30:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 30
            self.add_effect(ShieldEffect("Магический щит", 3, self.intellect // 2))
            self.cooldowns[skill] = 4
            self.log(f"{self.name} использует {skill} и получает магический щит!")
            return 0

class Healer(Character):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._strength = 8 + level
        self._agility = 10 + level
        self._intellect = 20 + level * 2
        self.max_hp = 100 + level * 6
        self.hp = self.max_hp
        self.max_mp = 80 + level * 6
        self.mp = self.max_mp
        self.skills = ["Лечение", "Сильное лечение", "Божественный щит"]
        self.cooldowns = {skill: 0 for skill in self.skills}

    def basic_attack(self, target):
        damage = self.calculate_crit(self.intellect // 3 + random.randint(1, 3))
        target.hp = max(0, target.hp - damage)
        self.log(f"{self.name} атакует {target.name} и наносит {damage} урона!")
        return damage

    def use_skill(self, skill_index, target):
        if skill_index >= len(self.skills):
            self.log("Неверный индекс навыка!")
            return 0
        skill = self.skills[skill_index]
        if self.cooldowns[skill] > 0:
            self.log(f"Навык {skill} на перезарядке! Осталось ходов: {self.cooldowns[skill]}")
            return 0
        if skill == "Лечение":
            if self.mp < 15:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 15
            heal = self.intellect + random.randint(5, 10)
            target.hp = min(target.max_hp, target.hp + heal)
            self.cooldowns[skill] = 1
            self.log(f"{self.name} использует {skill} на {target.name} и восстанавливает {heal} HP!")
            return -heal
        elif skill == "Сильное лечение":
            if self.mp < 30:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 30
            heal = int(self.intellect * 1.5) + random.randint(10, 20)
            target.hp = min(target.max_hp, target.hp + heal)
            self.cooldowns[skill] = 3
            self.log(f"{self.name} использует {skill} на {target.name} и восстанавливает {heal} HP!")
            return -heal
        elif skill == "Божественный щит":
            if self.mp < 40:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 40
            target.add_effect(ShieldEffect("Божественный щит", 2, self.intellect))
            self.cooldowns[skill] = 5
            self.log(f"{self.name} использует {skill} на {target.name}!")
            return 0

# Класс босса с фазами
class Boss(Character):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._strength = 30 + level * 3
        self._agility = 15 + level
        self._intellect = 20 + level * 2
        self.max_hp = 500 + level * 50
        self.hp = self.max_hp
        self.max_mp = 200 + level * 20
        self.mp = self.max_mp
        self.phase = 1
        self.skills = ["Мощный удар", "Огненный взрыв", "Исцеление", "Призыв помощников"]
        self.cooldowns = {skill: 0 for skill in self.skills}

    def basic_attack(self, target):
        damage = self.calculate_crit(self.strength + random.randint(5, 10))
        target.hp = max(0, target.hp - damage)
        self.log(f"{self.name} атакует {target.name} и наносит {damage} урона!")
        return damage

    def use_skill(self, skill_index, targets):
        if self.hp < self.max_hp * 0.3 and self.phase == 1:
            self.phase = 2
            self.log(f"{self.name} входит в фазу ярости! Его атаки усиливаются!")

        if self.phase == 1:
            if self.hp < self.max_hp * 0.7 and random.random() < 0.3:
                skill = "Исцеление"
            else:
                skill = random.choice(["Мощный удар", "Огненный взрыв"])
        else:
            skill = random.choice(["Мощный удар", "Огненный взрыв", "Призыв помощников"])

        skill_index = self.skills.index(skill)
        if self.cooldowns[skill] > 0:
            target = random.choice([t for t in targets if t.is_alive])
            return self.basic_attack(target)
        if skill == "Мощный удар":
            if self.mp < 20:
                target = random.choice([t for t in targets if t.is_alive])
                return self.basic_attack(target)
            self.mp -= 20
            alive_targets = [t for t in targets if t.is_alive]
            if not alive_targets:
                return 0
            target = random.choice(alive_targets)
            damage = self.calculate_crit(self.strength * 2 + random.randint(10, 20), 0.3)
            target.hp = max(0, target.hp - damage)
            self.cooldowns[skill] = 2
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage
        elif skill == "Огненный взрыв":
            if self.mp < 40:
                target = random.choice([t for t in targets if t.is_alive])
                return self.basic_attack(target)
            self.mp -= 40
            damage = self.calculate_crit(self.intellect + random.randint(5, 15), 0.2)
            alive_targets = [t for t in targets if t.is_alive]
            for target in alive_targets:
                target.hp = max(0, target.hp - damage)
                target.add_effect(BurnEffect("Горение", 2, self.intellect // 5))
            self.cooldowns[skill] = 3
            self.log(f"{self.name} использует {skill} на всю группу и наносит {damage} урона каждому!")
            return damage
        elif skill == "Исцеление":
            if self.mp < 50:
                target = random.choice([t for t in targets if t.is_alive])
                return self.basic_attack(target)
            self.mp -= 50
            heal = int(self.intellect * 1.5) + random.randint(20, 30)
            self.hp = min(self.max_hp, self.hp + heal)
            self.cooldowns[skill] = 4
            self.log(f"{self.name} использует {skill} и восстанавливает {heal} HP!")
            return -heal
        elif skill == "Призыв помощников":
            if self.mp < 60:
                target = random.choice([t for t in targets if t.is_alive])
                return self.basic_attack(target)
            self.mp -= 60
            self.log(f"{self.name} призывает помощников! Бой усложняется!")
            self.cooldowns[skill] = 5
            return 0

# Итератор для порядка ходов
class TurnOrder:
    def __init__(self, participants):
        self.participants = [p for p in participants if p.is_alive]

    def __iter__(self):
        sorted_participants = sorted(self.participants, key=lambda x: x.agility, reverse=True)
        return iter(sorted_participants)

# Контекстный менеджер для логирования
class BattleLogger:
    def __init__(self, filename):
        self.filename = filename
        self.log_entries = []

    def __enter__(self):
        self.start_time = datetime.now()
        self.log_entries.append(f"=== Начало битвы: {self.start_time} ===")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end_time = datetime.now()
        duration = self.end_time - self.start_time
        self.log_entries.append(f"=== Конец битвы: {self.end_time} ===")
        self.log_entries.append(f"=== Длительность: {duration} ===")
        with open(self.filename, 'w', encoding='utf-8') as f:
            for entry in self.log_entries:
                f.write(entry + '\n')

    def add_entry(self, entry):
        self.log_entries.append(entry)

# Класс битвы
class Battle:
    def __init__(self, party, boss, seed=None):
        self.party = party
        self.boss = boss
        self.turn_count = 0
        self.log = []
        if seed is not None:
            random.seed(seed)

    def log_message(self, message):
        self.log.append(message)
        print(message)

    def start_battle(self):
        self.log_message("=== НАЧАЛО БИТВЫ ===")
        self.log_message(f"Пати: {[char.name for char in self.party]} против Босса: {self.boss.name}")

        while any(char.is_alive for char in self.party) and self.boss.is_alive:
            self.turn_count += 1
            self.log_message(f"\n=== Ход {self.turn_count} ===")

            # Обновляем эффекты и перезарядки
            all_characters = self.party + [self.boss]
            for character in all_characters:
                if character.is_alive:
                    character.update_effects()
                    character.update_cooldowns()

            # Определяем порядок ходов
            participants = [char for char in self.party if char.is_alive]
            if self.boss.is_alive:
                participants.append(self.boss)

            turn_order = TurnOrder(participants)

            for actor in turn_order:
                if not actor.is_alive:
                    continue

                self.log_message(f"\nХод {actor.name}:")

                if actor in self.party:
                    # Ход игрока
                    alive_party = [char for char in self.party if char.is_alive]
                    if isinstance(actor, Healer) and any(char.hp < char.max_hp * 0.5 for char in alive_party):
                        wounded = [char for char in alive_party if char.hp < char.max_hp * 0.5]
                        target = random.choice(wounded)
                        actor.use_skill(0, target)
                    else:
                        target = self.boss
                        if random.random() < 0.7:
                            actor.basic_attack(target)
                        else:
                            skill_index = random.randint(0, len(actor.skills) - 1)
                            actor.use_skill(skill_index, target)
                else:
                    # Ход босса
                    alive_party = [char for char in self.party if char.is_alive]
                    if not alive_party:
                        break
                    if random.random() < 0.6:
                        skill_index = random.randint(0, len(actor.skills) - 1)
                        actor.use_skill(skill_index, alive_party)
                    else:
                        target = random.choice(alive_party)
                        actor.basic_attack(target)

                # Проверяем условия окончания боя
                if not self.boss.is_alive:
                    self.log_message(f"\n=== БОСС ПОБЕЖДЕН! ===")
                    break
                if not any(char.is_alive for char in self.party):
                    self.log_message(f"\n=== ПАТИ ПОБЕЖДЕНА! ===")
                    break

            # Состояние после хода
            self.log_message(f"\nСостояние после хода {self.turn_count}:")
            for char in self.party:
                status = "ЖИВ" if char.is_alive else "МЕРТВ"
                self.log_message(f"  {char.name}: {status}, HP: {char.hp}/{char.max_hp}")
            boss_status = "ЖИВ" if self.boss.is_alive else "МЕРТВ"
            self.log_message(f"  {self.boss.name}: {boss_status}, HP: {self.boss.hp}/{self.boss.max_hp}")

            if self.turn_count >= 50:
                self.log_message("Превышено максимальное количество ходов! Бой завершен.")
                break

        # Результат боя
        if any(char.is_alive for char in self.party):
            self.log_message("\n=== ПОБЕДА! Пати победила босса! ===")
            return "win"
        else:
            self.log_message("\n=== ПОРАЖЕНИЕ! Босс победил пати! ===")
            return "lose"

    def save_state(self, filename):
        state = {
            'turn_count': self.turn_count,
            'party': [{
                'name': char.name,
                'class': char.__class__.__name__,
                'hp': char.hp,
                'max_hp': char.max_hp,
                'mp': char.mp,
                'max_mp': char.max_mp
            } for char in self.party],
            'boss': {
                'name': self.boss.name,
                'hp': self.boss.hp,
                'max_hp': self.boss.max_hp,
                'mp': self.boss.mp,
                'max_mp': self.boss.max_mp,
                'phase': self.boss.phase
            },
            'log': self.log[-20:]
        }
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(state, f, indent=2, ensure_ascii=False)
        self.log_message(f"Состояние сохранено в {filename}")

    # Методы для совместимости с main.py
    def start(self):
        return self.start_battle() == "win"

    def get_battle_log(self):
        return self.log

    @property
    def round_number(self):
        return self.turn_count

# === КОД ИЗ ФАЙЛА "main.docx" ===

def choose_difficulty():
    print("Выберите сложность:")
    print("1. Легкая (босс ур. 3)")
    print("2. Средняя (босс ур. 5)")
    print("3. Сложная (босс ур. 8)")
    while True:
        choice = input("Ваш выбор (1-3): ").strip()
        if choice in ['1', '2', '3']:
            levels = {'1': 3, '2': 5, '3': 8}
            return levels[choice]
        print("Пожалуйста, введите 1, 2 или 3")

def create_party():
    print("\n СОЗДАНИЕ КОМАНДЫ")
    classes = {
        '1': ('Воин', Warrior),
        '2': ('Маг', Mage),
        '3': ('Лекарь', Healer)
    }
    party = []
    for i in range(3):
        print(f"\nСоздание персонажа {i + 1}:")
        print("Доступные классы:")
        for key, (name, _) in classes.items():
            print(f"{key}. {name}")
        while True:
            class_choice = input("Выберите класс (1-3): ").strip()
            if class_choice in classes:
                class_name, class_obj = classes[class_choice]
                break
            print("Пожалуйста, введите 1, 2 или 3")
        name = input("Введите имя персонажа: ").strip()
        if not name:
            name = f"{class_name}{i + 1}"
        character = class_obj(name, level=5)
        party.append(character)
        print(f"Создан: {character}")
    return party

def show_party_status(party):
    print("\nВАША КОМАНДА")
    for i, char in enumerate(party, 1):
        status = "МЕРТВ" if not char.is_alive else "ЖИВ"
        print(f"{i}. {char.name} ({char.__class__.__name__}) - {status}")
        print(f"   HP: {char.hp:.1f}/{char.max_hp} | MP: {char.mp:.1f}/{char.max_mp}")
        if hasattr(char, 'active_effects') and char.active_effects:
            print(f"   Эффекты: {', '.join(char.active_effects)}")

def main():
    print("ДОБРО ПОЖАЛОВАТЬ В ПАТИ ПРОТИВ БОССА!")

    random_seed = input("Введите seed для случайной генерации (или Enter для случайного): ").strip()
    if random_seed:
        random.seed(random_seed)
        print(f"Используется seed: {random_seed}")

    difficulty = choose_difficulty()
    party = create_party()

    boss_names = ["Дракон Гиммелут", "Демон Капучин", "Сфинктерион"]
    boss_name = random.choice(boss_names)
    boss = Boss(boss_name, level=difficulty)

    print(f"\nВАШ ПРОТИВНИК: {boss}")

    input("\nНажмите Enter чтобы начать бой...")

    battle = Battle(party, boss)
    victory = battle.start()

    print("\n")
    if victory:
        print("ПОЗДРАВЛЯЕМ! ВЫ ПОБЕДИЛИ!")
    else:
        print("ВЫ ПРОИГРАЛИ... ")

    print("\nСТАТИСТИКА БОЯ")
    print(f"Продолжительность: {battle.round_number} раундов")
    print(f"Босс: {boss.hp:.1f}/{boss.max_hp} HP")
    alive_count = sum(1 for char in party if char.is_alive)
    print(f"Выживших в пати: {alive_count}/{len(party)}")

    log_filename = f"battle_log_{random_seed if random_seed else 'random'}.txt"
    with open(log_filename, 'w', encoding='utf-8') as f:
        f.write("\n".join(battle.get_battle_log()))

    print(f"\nПолный лог боя сохранен в: {log_filename}")
    battle.save_state("battle_state.json")

if __name__ == "__main__":
    main()