# -*- coding: utf-8 -*-
"""Полный рабочий код Янполь_Колосовская

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ERQBGkaodlgevhnJK2eBXEJwdSKh4PQT
"""

# === ПОЛНЫЙ РАБОЧИЙ КОД МИНИ-ИГРЫ ===

from abc import ABC, abstractmethod
import random
import json
from datetime import datetime
import unittest

# Дескриптор для валидации характеристик
class BoundedStat:
    def __init__(self, min_val=0, max_val=100):
        self.min_val = min_val
        self.max_val = max_val

    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, instance, owner):
        return instance.__dict__.get(self.name, self.min_val)

    def __set__(self, instance, value):
        if not (self.min_val <= value <= self.max_val):
            raise ValueError(f"{self.name} must be between {self.min_val} and {self.max_val}")
        instance.__dict__[self.name] = value

# Базовый класс Human
class Human:
    hp = BoundedStat(0, 1000)
    mp = BoundedStat(0, 500)
    strength = BoundedStat(1, 100)
    agility = BoundedStat(1, 100)
    intellect = BoundedStat(1, 100)

    def __init__(self, name, level=1):
        self.name = name
        self.level = level
        self._hp = 100
        self._mp = 50
        self._strength = 10
        self._agility = 10
        self._intellect = 10
        self.max_hp = 100
        self.max_mp = 50

    @property
    def is_alive(self):
        return self.hp > 0

    def __str__(self):
        return f"{self.name} (Lvl {self.level}) - HP: {self.hp}/{self.max_hp}, MP: {self.mp}/{self.max_mp}"

    def __repr__(self):
        return f"{self.__class__.__name__}('{self.name}', {self.level})"

# Миксин для логирования
class LoggerMixin:
    def log(self, message):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] {message}")

# Миксин для критического удара
class CritMixin:
    def calculate_crit(self, base_damage, crit_chance=0.1):
        if random.random() < crit_chance:
            self.log(f"{self.name} наносит критический удар!")
            return base_damage * 2
        return base_damage

# Классы эффектов
class Effect(ABC):
    def __init__(self, name, duration):
        self.name = name
        self.duration = duration
        self.original_duration = duration
        self.applied = False

    @abstractmethod
    def apply(self, target):
        pass

    @abstractmethod
    def remove(self, target):
        pass

class BurnEffect(Effect):
    def __init__(self, name, duration, damage_per_turn):
        super().__init__(name, duration)
        self.damage_per_turn = damage_per_turn

    def apply(self, target):
        target.hp -= self.damage_per_turn
        target.log(f"{target.name} горит и получает {self.damage_per_turn} урона!")

    def remove(self, target):
        target.log(f"Эффект горения с {target.name} снят")

class ShieldEffect(Effect):
    def __init__(self, name, duration, shield_amount):
        super().__init__(name, duration)
        self.shield_amount = shield_amount
        self.original_max_hp = 0

    def apply(self, target):
        if not self.applied:
            self.applied = True
            self.original_max_hp = target.max_hp
            target.max_hp += self.shield_amount
            target.hp += self.shield_amount
            target.log(f"{target.name} получает щит на {self.shield_amount} HP!")

    def remove(self, target):
        if self.applied:
            target.max_hp = self.original_max_hp
            target.hp = min(target.hp, target.max_hp)
            target.log(f"Щит с {target.name} снят")

class SlowEffect(Effect):
    def __init__(self, name, duration):
        super().__init__(name, duration)
        self.original_agility = 0

    def apply(self, target):
        if not self.applied:
            self.applied = True
            self.original_agility = target.agility
            target.agility = max(1, target.agility // 2)
            target.log(f"{target.name} замедлен! Ловкость уменьшена до {target.agility}")

    def remove(self, target):
        if self.applied:
            target.agility = self.original_agility
            target.log(f"Замедление с {target.name} снято. Ловкость восстановлена до {target.agility}")

# Абстрактный класс Character
class Character(Human, ABC, LoggerMixin, CritMixin):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self.skills = []
        self.effects = []
        self.cooldowns = {}
        self.inventory = []

    @abstractmethod
    def basic_attack(self, target):
        pass

    @abstractmethod
    def use_skill(self, skill_index, target):
        pass

    def add_effect(self, effect):
        self.effects.append(effect)
        self.log(f"{self.name} получает эффект: {effect.name}")

    def remove_effect(self, effect):
        if effect in self.effects:
            self.effects.remove(effect)
            self.log(f"Эффект {effect.name} с {self.name} снят")

    def update_effects(self):
        effects_to_remove = []
        for effect in self.effects:
            effect.apply(self)
            effect.duration -= 1
            if effect.duration <= 0:
                effects_to_remove.append(effect)

        for effect in effects_to_remove:
            effect.remove(self)
            self.remove_effect(effect)

    def update_cooldowns(self):
        for skill in self.cooldowns:
            if self.cooldowns[skill] > 0:
                self.cooldowns[skill] -= 1

    def __str__(self):
        base_str = super().__str__()
        effects_str = ", ".join([f"{eff.name}({eff.duration})" for eff in self.effects]) if self.effects else "нет"
        return f"{base_str} | Эффекты: {effects_str}"

# Классы персонажей
class Warrior(Character):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._strength = 20 + level * 2
        self._agility = 10 + level
        self._intellect = 5 + level
        self.max_hp = 150 + level * 10
        self.hp = self.max_hp
        self.max_mp = 30 + level * 2
        self.mp = self.max_mp
        self.skills = ["Сильный удар", "Защитная стойка", "Размашистый удар"]
        self.cooldowns = {skill: 0 for skill in self.skills}

    def basic_attack(self, target):
        damage = self.calculate_crit(self.strength + random.randint(1, 5))
        target.hp = max(0, target.hp - damage)
        self.log(f"{self.name} атакует {target.name} и наносит {damage} урона!")
        return damage

    def use_skill(self, skill_index, target):
        if skill_index >= len(self.skills):
            self.log("Неверный индекс навыка!")
            return 0

        skill = self.skills[skill_index]

        if self.cooldowns[skill] > 0:
            self.log(f"Навык {skill} на перезарядке! Осталось ходов: {self.cooldowns[skill]}")
            return 0

        if skill == "Сильный удар":
            if self.mp < 10:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 10
            damage = self.calculate_crit(self.strength * 2 + random.randint(5, 10), 0.2)
            target.hp = max(0, target.hp - damage)
            self.cooldowns[skill] = 2
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage

        elif skill == "Защитная стойка":
            if self.mp < 15:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 15
            self.add_effect(ShieldEffect("Щит воина", 2, self.strength))
            self.cooldowns[skill] = 3
            self.log(f"{self.name} использует {skill} и получает щит!")
            return 0

        elif skill == "Размашистый удар":
            if self.mp < 20:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 20
            damage = self.calculate_crit(self.strength * 1.5 + random.randint(3, 8), 0.15)
            target.hp = max(0, target.hp - damage)
            self.cooldowns[skill] = 4
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage

class Mage(Character):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._strength = 5 + level
        self._agility = 8 + level
        self._intellect = 25 + level * 3
        self.max_hp = 80 + level * 5
        self.hp = self.max_hp
        self.max_mp = 100 + level * 8
        self.mp = self.max_mp
        self.skills = ["Огненный шар", "Ледяная стрела", "Магический щит"]
        self.cooldowns = {skill: 0 for skill in self.skills}

    def basic_attack(self, target):
        damage = self.calculate_crit(self.intellect // 2 + random.randint(1, 3))
        target.hp = max(0, target.hp - damage)
        self.log(f"{self.name} атакует {target.name} магией и наносит {damage} урона!")
        return damage

    def use_skill(self, skill_index, target):
        if skill_index >= len(self.skills):
            self.log("Неверный индекс навыка!")
            return 0

        skill = self.skills[skill_index]

        if self.cooldowns[skill] > 0:
            self.log(f"Навык {skill} на перезарядке! Осталось ходов: {self.cooldowns[skill]}")
            return 0

        if skill == "Огненный шар":
            if self.mp < 25:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 25
            damage = self.calculate_crit(self.intellect * 1.5 + random.randint(5, 15), 0.25)
            target.hp = max(0, target.hp - damage)
            target.add_effect(BurnEffect("Горение", 3, self.intellect // 4))
            self.cooldowns[skill] = 3
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage

        elif skill == "Ледяная стрела":
            if self.mp < 20:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 20
            damage = self.calculate_crit(self.intellect + random.randint(3, 10), 0.2)
            target.hp = max(0, target.hp - damage)
            target.add_effect(SlowEffect("Замедление", 2))
            self.cooldowns[skill] = 2
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage

        elif skill == "Магический щит":
            if self.mp < 30:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 30
            self.add_effect(ShieldEffect("Магический щит", 3, self.intellect // 2))
            self.cooldowns[skill] = 4
            self.log(f"{self.name} использует {skill} и получает магический щит!")
            return 0

class Healer(Character):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._strength = 8 + level
        self._agility = 10 + level
        self._intellect = 20 + level * 2
        self.max_hp = 100 + level * 6
        self.hp = self.max_hp
        self.max_mp = 80 + level * 6
        self.mp = self.max_mp
        self.skills = ["Лечение", "Сильное лечение", "Божественный щит"]
        self.cooldowns = {skill: 0 for skill in self.skills}

    def basic_attack(self, target):
        damage = self.calculate_crit(self.intellect // 3 + random.randint(1, 3))
        target.hp = max(0, target.hp - damage)
        self.log(f"{self.name} атакует {target.name} и наносит {damage} урона!")
        return damage

    def use_skill(self, skill_index, target):
        if skill_index >= len(self.skills):
            self.log("Неверный индекс навыка!")
            return 0

        skill = self.skills[skill_index]

        if self.cooldowns[skill] > 0:
            self.log(f"Навык {skill} на перезарядке! Осталось ходов: {self.cooldowns[skill]}")
            return 0

        if skill == "Лечение":
            if self.mp < 15:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 15
            heal = self.intellect + random.randint(5, 10)
            target.hp = min(target.max_hp, target.hp + heal)
            self.cooldowns[skill] = 1
            self.log(f"{self.name} использует {skill} на {target.name} и восстанавливает {heal} HP!")
            return -heal

        elif skill == "Сильное лечение":
            if self.mp < 30:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 30
            heal = int(self.intellect * 1.5) + random.randint(10, 20)
            target.hp = min(target.max_hp, target.hp + heal)
            self.cooldowns[skill] = 3
            self.log(f"{self.name} использует {skill} на {target.name} и восстанавливает {heal} HP!")
            return -heal

        elif skill == "Божественный щит":
            if self.mp < 40:
                self.log("Недостаточно маны!")
                return 0
            self.mp -= 40
            target.add_effect(ShieldEffect("Божественный щит", 2, self.intellect))
            self.cooldowns[skill] = 5
            self.log(f"{self.name} использует {skill} на {target.name}!")
            return 0

# Класс босса с фазами
class Boss(Character):
    def __init__(self, name, level=1):
        super().__init__(name, level)
        self._strength = 30 + level * 3
        self._agility = 15 + level
        self._intellect = 20 + level * 2
        self.max_hp = 500 + level * 50
        self.hp = self.max_hp
        self.max_mp = 200 + level * 20
        self.mp = self.max_mp
        self.phase = 1
        self.skills = ["Мощный удар", "Огненный взрыв", "Исцеление", "Призыв помощников"]
        self.cooldowns = {skill: 0 for skill in self.skills}

    def basic_attack(self, target):
        damage = self.calculate_crit(self.strength + random.randint(5, 10))
        target.hp = max(0, target.hp - damage)
        self.log(f"{self.name} атакует {target.name} и наносит {damage} урона!")
        return damage

    def use_skill(self, skill_index, targets):
        if self.hp < self.max_hp * 0.3 and self.phase == 1:
            self.phase = 2
            self.log(f"{self.name} входит в фазу ярости! Его атаки усиливаются!")

        if self.phase == 1:
            if self.hp < self.max_hp * 0.7 and random.random() < 0.3:
                skill = "Исцеление"
            else:
                skill = random.choice(["Мощный удар", "Огненный взрыв"])
        else:
            skill = random.choice(["Мощный удар", "Огненный взрыв", "Призыв помощников"])

        skill_index = self.skills.index(skill)

        if self.cooldowns[skill] > 0:
            target = random.choice([t for t in targets if t.is_alive])
            return self.basic_attack(target)

        if skill == "Мощный удар":
            if self.mp < 20:
                target = random.choice([t for t in targets if t.is_alive])
                return self.basic_attack(target)
            self.mp -= 20
            alive_targets = [t for t in targets if t.is_alive]
            if not alive_targets:
                return 0
            target = random.choice(alive_targets)
            damage = self.calculate_crit(self.strength * 2 + random.randint(10, 20), 0.3)
            target.hp = max(0, target.hp - damage)
            self.cooldowns[skill] = 2
            self.log(f"{self.name} использует {skill} на {target.name} и наносит {damage} урона!")
            return damage

        elif skill == "Огненный взрыв":
            if self.mp < 40:
                target = random.choice([t for t in targets if t.is_alive])
                return self.basic_attack(target)
            self.mp -= 40
            damage = self.calculate_crit(self.intellect + random.randint(5, 15), 0.2)
            alive_targets = [t for t in targets if t.is_alive]
            for target in alive_targets:
                target.hp = max(0, target.hp - damage)
                target.add_effect(BurnEffect("Горение", 2, self.intellect // 5))
            self.cooldowns[skill] = 3
            self.log(f"{self.name} использует {skill} на всю группу и наносит {damage} урона каждому!")
            return damage

        elif skill == "Исцеление":
            if self.mp < 50:
                target = random.choice([t for t in targets if t.is_alive])
                return self.basic_attack(target)
            self.mp -= 50
            heal = int(self.intellect * 1.5) + random.randint(20, 30)
            self.hp = min(self.max_hp, self.hp + heal)
            self.cooldowns[skill] = 4
            self.log(f"{self.name} использует {skill} и восстанавливает {heal} HP!")
            return -heal

        elif skill == "Призыв помощников":
            if self.mp < 60:
                target = random.choice([t for t in targets if t.is_alive])
                return self.basic_attack(target)
            self.mp -= 60
            self.log(f"{self.name} призывает помощников! Бой усложняется!")
            self.cooldowns[skill] = 5
            return 0

# Итератор для порядка ходов
class TurnOrder:
    def __init__(self, participants):
        self.participants = [p for p in participants if p.is_alive]

    def __iter__(self):
        sorted_participants = sorted(self.participants, key=lambda x: x.agility, reverse=True)
        return iter(sorted_participants)

# Контекстный менеджер для логирования
class BattleLogger:
    def __init__(self, filename):
        self.filename = filename
        self.log_entries = []

    def __enter__(self):
        self.start_time = datetime.now()
        self.log_entries.append(f"=== Начало битвы: {self.start_time} ===")
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end_time = datetime.now()
        duration = self.end_time - self.start_time
        self.log_entries.append(f"=== Конец битвы: {self.end_time} ===")
        self.log_entries.append(f"=== Длительность: {duration} ===")

        with open(self.filename, 'w', encoding='utf-8') as f:
            for entry in self.log_entries:
                f.write(entry + '\n')

    def add_entry(self, entry):
        self.log_entries.append(entry)

# Класс битвы
class Battle:
    def __init__(self, party, boss, seed=None):
        self.party = party
        self.boss = boss
        self.turn_count = 0
        self.log = []

        if seed is not None:
            random.seed(seed)

    def log_message(self, message):
        self.log.append(message)
        print(message)

    def start_battle(self):
        self.log_message("=== НАЧАЛО БИТВЫ ===")
        self.log_message(f"Пати: {[char.name for char in self.party]} против Босса: {self.boss.name}")

        while any(char.is_alive for char in self.party) and self.boss.is_alive:
            self.turn_count += 1
            self.log_message(f"\n=== Ход {self.turn_count} ===")

            # Обновляем эффекты и перезарядки
            all_characters = self.party + [self.boss]
            for character in all_characters:
                if character.is_alive:
                    character.update_effects()
                    character.update_cooldowns()

            # Определяем порядок ходов
            participants = [char for char in self.party if char.is_alive]
            if self.boss.is_alive:
                participants.append(self.boss)

            turn_order = TurnOrder(participants)

            for actor in turn_order:
                if not actor.is_alive:
                    continue

                self.log_message(f"\nХод {actor.name}:")

                if actor in self.party:
                    # Ход игрока
                    alive_party = [char for char in self.party if char.is_alive]

                    if isinstance(actor, Healer) and any(char.hp < char.max_hp * 0.5 for char in alive_party):
                        wounded = [char for char in alive_party if char.hp < char.max_hp * 0.5]
                        target = random.choice(wounded)
                        actor.use_skill(0, target)
                    else:
                        target = self.boss
                        if random.random() < 0.7:
                            actor.basic_attack(target)
                        else:
                            skill_index = random.randint(0, len(actor.skills) - 1)
                            actor.use_skill(skill_index, target)
                else:
                    # Ход босса
                    alive_party = [char for char in self.party if char.is_alive]
                    if not alive_party:
                        break

                    if random.random() < 0.6:
                        skill_index = random.randint(0, len(actor.skills) - 1)
                        actor.use_skill(skill_index, alive_party)
                    else:
                        target = random.choice(alive_party)
                        actor.basic_attack(target)

                # Проверяем условия окончания боя
                if not self.boss.is_alive:
                    self.log_message(f"\n=== БОСС ПОБЕЖДЕН! ===")
                    break

                if not any(char.is_alive for char in self.party):
                    self.log_message(f"\n=== ПАТИ ПОБЕЖДЕНА! ===")
                    break

            # Состояние после хода
            self.log_message(f"\nСостояние после хода {self.turn_count}:")
            for char in self.party:
                status = "ЖИВ" if char.is_alive else "МЕРТВ"
                self.log_message(f"  {char.name}: {status}, HP: {char.hp}/{char.max_hp}")
            boss_status = "ЖИВ" if self.boss.is_alive else "МЕРТВ"
            self.log_message(f"  {self.boss.name}: {boss_status}, HP: {self.boss.hp}/{self.boss.max_hp}")

            if self.turn_count >= 50:
                self.log_message("Превышено максимальное количество ходов! Бой завершен.")
                break

        # Результат боя
        if any(char.is_alive for char in self.party):
            self.log_message("\n=== ПОБЕДА! Пати победила босса! ===")
            return "win"
        else:
            self.log_message("\n=== ПОРАЖЕНИЕ! Босс победил пати! ===")
            return "lose"

    def save_state(self, filename):
        state = {
            'turn_count': self.turn_count,
            'party': [{
                'name': char.name,
                'class': char.__class__.__name__,
                'hp': char.hp,
                'max_hp': char.max_hp,
                'mp': char.mp,
                'max_mp': char.max_mp
            } for char in self.party],
            'boss': {
                'name': self.boss.name,
                'hp': self.boss.hp,
                'max_hp': self.boss.max_hp,
                'mp': self.boss.mp,
                'max_mp': self.boss.max_mp,
                'phase': self.boss.phase
            },
            'log': self.log[-20:]
        }

        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(state, f, indent=2, ensure_ascii=False)

        self.log_message(f"Состояние сохранено в {filename}")

# Демонстрация игры
def demo_battle():
    print("=== ДЕМО-РЕЖИМ МИНИ-ИГРЫ 'ПАТИ ПРОТИВ БОССА' ===\n")

    # Создаем пати
    warrior = Warrior("Боромир", 5)
    mage = Mage("Гэндальф", 5)
    healer = Healer("Элронд", 5)

    party = [warrior, mage, healer]

    # Создаем босса
    boss = Boss("Саурон", 5)

    # Запускаем битву
    battle = Battle(party, boss, seed=42)

    # Используем контекстный менеджер для логирования
    with BattleLogger("battle_log.txt") as logger:
        result = battle.start_battle()

        # Сохраняем состояние
        battle.save_state("battle_state.json")

    return result

# Тесты
class TestBattle(unittest.TestCase):
    def setUp(self):
        self.warrior = Warrior("Тестовый воин", 1)
        self.mage = Mage("Тестовый маг", 1)
        self.healer = Healer("Тестовый лекарь", 1)
        self.boss = Boss("Тестовый босс", 1)

        self.party = [self.warrior, self.mage, self.healer]

    def test_character_creation(self):
        self.assertEqual(self.warrior.name, "Тестовый воин")
        self.assertEqual(self.warrior.level, 1)
        self.assertTrue(self.warrior.is_alive)
        self.assertGreater(self.warrior.strength, 0)

    def test_basic_attack(self):
        initial_hp = self.boss.hp
        damage = self.warrior.basic_attack(self.boss)
        self.assertEqual(self.boss.hp, initial_hp - damage)
        self.assertGreater(damage, 0)

    def test_skill_usage(self):
        initial_mp = self.mage.mp
        self.mage.use_skill(0, self.boss)
        self.assertLess(self.mage.mp, initial_mp)

    def test_effects(self):
        burn_effect = BurnEffect("Тестовое горение", 2, 5)
        self.boss.add_effect(burn_effect)
        self.assertIn(burn_effect, self.boss.effects)

        initial_hp = self.boss.hp
        self.boss.update_effects()
        self.assertLess(self.boss.hp, initial_hp)

    def test_battle_creation(self):
        battle = Battle(self.party, self.boss, seed=123)
        self.assertEqual(len(battle.party), 3)
        self.assertEqual(battle.boss.name, "Тестовый босс")
        self.assertEqual(battle.turn_count, 0)

# Запуск демо-режима
if __name__ == "__main__":
    print("Запуск демо-битвы...")
    demo_battle()

    print("\n" + "="*50)
    print("Запуск тестов...")
    unittest.main(argv=[''], verbosity=2, exit=False)